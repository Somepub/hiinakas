// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v4.22.0
// source: card.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "card";

export enum Rank {
  TWO = 0,
  THREE = 1,
  FOUR = 2,
  FIVE = 3,
  SIX = 4,
  SEVEN = 5,
  EIGHT = 6,
  NINE = 7,
  TEN = 8,
  JACK = 9,
  QUEEN = 10,
  KING = 11,
  ACE = 12,
  UNRECOGNIZED = -1,
}

export function rankFromJSON(object: any): Rank {
  switch (object) {
    case 0:
    case "TWO":
      return Rank.TWO;
    case 1:
    case "THREE":
      return Rank.THREE;
    case 2:
    case "FOUR":
      return Rank.FOUR;
    case 3:
    case "FIVE":
      return Rank.FIVE;
    case 4:
    case "SIX":
      return Rank.SIX;
    case 5:
    case "SEVEN":
      return Rank.SEVEN;
    case 6:
    case "EIGHT":
      return Rank.EIGHT;
    case 7:
    case "NINE":
      return Rank.NINE;
    case 8:
    case "TEN":
      return Rank.TEN;
    case 9:
    case "JACK":
      return Rank.JACK;
    case 10:
    case "QUEEN":
      return Rank.QUEEN;
    case 11:
    case "KING":
      return Rank.KING;
    case 12:
    case "ACE":
      return Rank.ACE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Rank.UNRECOGNIZED;
  }
}

export function rankToJSON(object: Rank): string {
  switch (object) {
    case Rank.TWO:
      return "TWO";
    case Rank.THREE:
      return "THREE";
    case Rank.FOUR:
      return "FOUR";
    case Rank.FIVE:
      return "FIVE";
    case Rank.SIX:
      return "SIX";
    case Rank.SEVEN:
      return "SEVEN";
    case Rank.EIGHT:
      return "EIGHT";
    case Rank.NINE:
      return "NINE";
    case Rank.TEN:
      return "TEN";
    case Rank.JACK:
      return "JACK";
    case Rank.QUEEN:
      return "QUEEN";
    case Rank.KING:
      return "KING";
    case Rank.ACE:
      return "ACE";
    case Rank.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Suit {
  HEARTS = 0,
  DIAMONDS = 1,
  CLUBS = 2,
  SPADES = 3,
  UNRECOGNIZED = -1,
}

export function suitFromJSON(object: any): Suit {
  switch (object) {
    case 0:
    case "HEARTS":
      return Suit.HEARTS;
    case 1:
    case "DIAMONDS":
      return Suit.DIAMONDS;
    case 2:
    case "CLUBS":
      return Suit.CLUBS;
    case 3:
    case "SPADES":
      return Suit.SPADES;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Suit.UNRECOGNIZED;
  }
}

export function suitToJSON(object: Suit): string {
  switch (object) {
    case Suit.HEARTS:
      return "HEARTS";
    case Suit.DIAMONDS:
      return "DIAMONDS";
    case Suit.CLUBS:
      return "CLUBS";
    case Suit.SPADES:
      return "SPADES";
    case Suit.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum Effect {
  NO_EFFECT = 0,
  TRANSPARENT = 1,
  CONSTRAINT = 2,
  ACE_KILLER = 3,
  DESTROY = 4,
  UNRECOGNIZED = -1,
}

export function effectFromJSON(object: any): Effect {
  switch (object) {
    case 0:
    case "NO_EFFECT":
      return Effect.NO_EFFECT;
    case 1:
    case "TRANSPARENT":
      return Effect.TRANSPARENT;
    case 2:
    case "CONSTRAINT":
      return Effect.CONSTRAINT;
    case 3:
    case "ACE_KILLER":
      return Effect.ACE_KILLER;
    case 4:
    case "DESTROY":
      return Effect.DESTROY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Effect.UNRECOGNIZED;
  }
}

export function effectToJSON(object: Effect): string {
  switch (object) {
    case Effect.NO_EFFECT:
      return "NO_EFFECT";
    case Effect.TRANSPARENT:
      return "TRANSPARENT";
    case Effect.CONSTRAINT:
      return "CONSTRAINT";
    case Effect.ACE_KILLER:
      return "ACE_KILLER";
    case Effect.DESTROY:
      return "DESTROY";
    case Effect.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Card {
  uid: string;
  rank: Rank;
  suit: Suit;
  effect: Effect;
}

export interface SmallCard {
  value: number;
}

function createBaseCard(): Card {
  return { uid: "", rank: 0, suit: 0, effect: 0 };
}

export const Card: MessageFns<Card> = {
  encode(message: Card, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.rank !== 0) {
      writer.uint32(16).int32(message.rank);
    }
    if (message.suit !== 0) {
      writer.uint32(24).int32(message.suit);
    }
    if (message.effect !== 0) {
      writer.uint32(32).int32(message.effect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Card {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rank = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.suit = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.effect = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Card {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      rank: isSet(object.rank) ? rankFromJSON(object.rank) : 0,
      suit: isSet(object.suit) ? suitFromJSON(object.suit) : 0,
      effect: isSet(object.effect) ? effectFromJSON(object.effect) : 0,
    };
  },

  toJSON(message: Card): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.rank !== 0) {
      obj.rank = rankToJSON(message.rank);
    }
    if (message.suit !== 0) {
      obj.suit = suitToJSON(message.suit);
    }
    if (message.effect !== 0) {
      obj.effect = effectToJSON(message.effect);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Card>, I>>(base?: I): Card {
    return Card.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Card>, I>>(object: I): Card {
    const message = createBaseCard();
    message.uid = object.uid ?? "";
    message.rank = object.rank ?? 0;
    message.suit = object.suit ?? 0;
    message.effect = object.effect ?? 0;
    return message;
  },
};

function createBaseSmallCard(): SmallCard {
  return { value: 0 };
}

export const SmallCard: MessageFns<SmallCard> = {
  encode(message: SmallCard, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).uint32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmallCard {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmallCard();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.value = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmallCard {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: SmallCard): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SmallCard>, I>>(base?: I): SmallCard {
    return SmallCard.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SmallCard>, I>>(object: I): SmallCard {
    const message = createBaseSmallCard();
    message.value = object.value ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
