// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.0
//   protoc               v4.22.0
// source: game.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Card, SmallCard } from "./card";
import { LobbyPlayer } from "./lobby";

export const protobufPackage = "game";

export enum GameInstanceMessageAction {
  INFO = 0,
  ERROR = 1,
  UNRECOGNIZED = -1,
}

export function gameInstanceMessageActionFromJSON(object: any): GameInstanceMessageAction {
  switch (object) {
    case 0:
    case "INFO":
      return GameInstanceMessageAction.INFO;
    case 1:
    case "ERROR":
      return GameInstanceMessageAction.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameInstanceMessageAction.UNRECOGNIZED;
  }
}

export function gameInstanceMessageActionToJSON(object: GameInstanceMessageAction): string {
  switch (object) {
    case GameInstanceMessageAction.INFO:
      return "INFO";
    case GameInstanceMessageAction.ERROR:
      return "ERROR";
    case GameInstanceMessageAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum GameInstanceAction {
  INIT = 0,
  PLAY_CARD = 1,
  END_TURN = 2,
  PICK_UP = 3,
  WIN = 4,
  UNRECOGNIZED = -1,
}

export function gameInstanceActionFromJSON(object: any): GameInstanceAction {
  switch (object) {
    case 0:
    case "INIT":
      return GameInstanceAction.INIT;
    case 1:
    case "PLAY_CARD":
      return GameInstanceAction.PLAY_CARD;
    case 2:
    case "END_TURN":
      return GameInstanceAction.END_TURN;
    case 3:
    case "PICK_UP":
      return GameInstanceAction.PICK_UP;
    case 4:
    case "WIN":
      return GameInstanceAction.WIN;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameInstanceAction.UNRECOGNIZED;
  }
}

export function gameInstanceActionToJSON(object: GameInstanceAction): string {
  switch (object) {
    case GameInstanceAction.INIT:
      return "INIT";
    case GameInstanceAction.PLAY_CARD:
      return "PLAY_CARD";
    case GameInstanceAction.END_TURN:
      return "END_TURN";
    case GameInstanceAction.PICK_UP:
      return "PICK_UP";
    case GameInstanceAction.WIN:
      return "WIN";
    case GameInstanceAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface GameTurnRequest {
  uid: string;
  player: LobbyPlayer | undefined;
  action: GameInstanceAction;
  cardId: string;
}

export interface GameTurnResponse {
  uid: string;
  gameTurn: GameTurn | undefined;
}

export interface GameTurn {
  status: GameTurnStatus | undefined;
  player: GameTurnPlayer | undefined;
  table: SmallCard[];
  deck: number;
  isWinner: boolean;
}

export interface GameTurnPlayer {
  name: string;
  isMyTurn: boolean;
  action: GameInstanceAction;
  message: GameInstanceMessage | undefined;
}

export interface GameInstanceMessage {
  type: GameInstanceMessageAction;
  message: string;
}

export interface GameTurnStatus {
  playerStatus: PlayerStatus | undefined;
  otherPlayers: OpponentPlayerStatus[];
}

export interface PlayerStatus {
  handCards: Card[];
  floorCards: SmallCard[];
  hiddenCards: number;
}

export interface OpponentPlayerStatus {
  name: string;
  handCards: number;
  floorCards: SmallCard[];
  hiddenCards: number;
}

export interface GameTurnFeedback {
  action: GameInstanceAction;
  message: GameInstanceMessage | undefined;
  hasWon: boolean;
  hasDisconnect: boolean;
}

function createBaseGameTurnRequest(): GameTurnRequest {
  return { uid: "", player: undefined, action: 0, cardId: "" };
}

export const GameTurnRequest: MessageFns<GameTurnRequest> = {
  encode(message: GameTurnRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.player !== undefined) {
      LobbyPlayer.encode(message.player, writer.uint32(18).fork()).join();
    }
    if (message.action !== 0) {
      writer.uint32(24).int32(message.action);
    }
    if (message.cardId !== "") {
      writer.uint32(34).string(message.cardId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTurnRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTurnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.player = LobbyPlayer.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.cardId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTurnRequest {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      player: isSet(object.player) ? LobbyPlayer.fromJSON(object.player) : undefined,
      action: isSet(object.action) ? gameInstanceActionFromJSON(object.action) : 0,
      cardId: isSet(object.cardId) ? globalThis.String(object.cardId) : "",
    };
  },

  toJSON(message: GameTurnRequest): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.player !== undefined) {
      obj.player = LobbyPlayer.toJSON(message.player);
    }
    if (message.action !== 0) {
      obj.action = gameInstanceActionToJSON(message.action);
    }
    if (message.cardId !== "") {
      obj.cardId = message.cardId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameTurnRequest>, I>>(base?: I): GameTurnRequest {
    return GameTurnRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameTurnRequest>, I>>(object: I): GameTurnRequest {
    const message = createBaseGameTurnRequest();
    message.uid = object.uid ?? "";
    message.player = (object.player !== undefined && object.player !== null)
      ? LobbyPlayer.fromPartial(object.player)
      : undefined;
    message.action = object.action ?? 0;
    message.cardId = object.cardId ?? "";
    return message;
  },
};

function createBaseGameTurnResponse(): GameTurnResponse {
  return { uid: "", gameTurn: undefined };
}

export const GameTurnResponse: MessageFns<GameTurnResponse> = {
  encode(message: GameTurnResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.gameTurn !== undefined) {
      GameTurn.encode(message.gameTurn, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTurnResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTurnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameTurn = GameTurn.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTurnResponse {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      gameTurn: isSet(object.gameTurn) ? GameTurn.fromJSON(object.gameTurn) : undefined,
    };
  },

  toJSON(message: GameTurnResponse): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.gameTurn !== undefined) {
      obj.gameTurn = GameTurn.toJSON(message.gameTurn);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameTurnResponse>, I>>(base?: I): GameTurnResponse {
    return GameTurnResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameTurnResponse>, I>>(object: I): GameTurnResponse {
    const message = createBaseGameTurnResponse();
    message.uid = object.uid ?? "";
    message.gameTurn = (object.gameTurn !== undefined && object.gameTurn !== null)
      ? GameTurn.fromPartial(object.gameTurn)
      : undefined;
    return message;
  },
};

function createBaseGameTurn(): GameTurn {
  return { status: undefined, player: undefined, table: [], deck: 0, isWinner: false };
}

export const GameTurn: MessageFns<GameTurn> = {
  encode(message: GameTurn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== undefined) {
      GameTurnStatus.encode(message.status, writer.uint32(10).fork()).join();
    }
    if (message.player !== undefined) {
      GameTurnPlayer.encode(message.player, writer.uint32(18).fork()).join();
    }
    for (const v of message.table) {
      SmallCard.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.deck !== 0) {
      writer.uint32(32).uint32(message.deck);
    }
    if (message.isWinner !== false) {
      writer.uint32(40).bool(message.isWinner);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTurn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTurn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.status = GameTurnStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.player = GameTurnPlayer.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.table.push(SmallCard.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.deck = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isWinner = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTurn {
    return {
      status: isSet(object.status) ? GameTurnStatus.fromJSON(object.status) : undefined,
      player: isSet(object.player) ? GameTurnPlayer.fromJSON(object.player) : undefined,
      table: globalThis.Array.isArray(object?.table) ? object.table.map((e: any) => SmallCard.fromJSON(e)) : [],
      deck: isSet(object.deck) ? globalThis.Number(object.deck) : 0,
      isWinner: isSet(object.isWinner) ? globalThis.Boolean(object.isWinner) : false,
    };
  },

  toJSON(message: GameTurn): unknown {
    const obj: any = {};
    if (message.status !== undefined) {
      obj.status = GameTurnStatus.toJSON(message.status);
    }
    if (message.player !== undefined) {
      obj.player = GameTurnPlayer.toJSON(message.player);
    }
    if (message.table?.length) {
      obj.table = message.table.map((e) => SmallCard.toJSON(e));
    }
    if (message.deck !== 0) {
      obj.deck = Math.round(message.deck);
    }
    if (message.isWinner !== false) {
      obj.isWinner = message.isWinner;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameTurn>, I>>(base?: I): GameTurn {
    return GameTurn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameTurn>, I>>(object: I): GameTurn {
    const message = createBaseGameTurn();
    message.status = (object.status !== undefined && object.status !== null)
      ? GameTurnStatus.fromPartial(object.status)
      : undefined;
    message.player = (object.player !== undefined && object.player !== null)
      ? GameTurnPlayer.fromPartial(object.player)
      : undefined;
    message.table = object.table?.map((e) => SmallCard.fromPartial(e)) || [];
    message.deck = object.deck ?? 0;
    message.isWinner = object.isWinner ?? false;
    return message;
  },
};

function createBaseGameTurnPlayer(): GameTurnPlayer {
  return { name: "", isMyTurn: false, action: 0, message: undefined };
}

export const GameTurnPlayer: MessageFns<GameTurnPlayer> = {
  encode(message: GameTurnPlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.isMyTurn !== false) {
      writer.uint32(16).bool(message.isMyTurn);
    }
    if (message.action !== 0) {
      writer.uint32(24).int32(message.action);
    }
    if (message.message !== undefined) {
      GameInstanceMessage.encode(message.message, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTurnPlayer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTurnPlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isMyTurn = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = GameInstanceMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTurnPlayer {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isMyTurn: isSet(object.isMyTurn) ? globalThis.Boolean(object.isMyTurn) : false,
      action: isSet(object.action) ? gameInstanceActionFromJSON(object.action) : 0,
      message: isSet(object.message) ? GameInstanceMessage.fromJSON(object.message) : undefined,
    };
  },

  toJSON(message: GameTurnPlayer): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isMyTurn !== false) {
      obj.isMyTurn = message.isMyTurn;
    }
    if (message.action !== 0) {
      obj.action = gameInstanceActionToJSON(message.action);
    }
    if (message.message !== undefined) {
      obj.message = GameInstanceMessage.toJSON(message.message);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameTurnPlayer>, I>>(base?: I): GameTurnPlayer {
    return GameTurnPlayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameTurnPlayer>, I>>(object: I): GameTurnPlayer {
    const message = createBaseGameTurnPlayer();
    message.name = object.name ?? "";
    message.isMyTurn = object.isMyTurn ?? false;
    message.action = object.action ?? 0;
    message.message = (object.message !== undefined && object.message !== null)
      ? GameInstanceMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseGameInstanceMessage(): GameInstanceMessage {
  return { type: 0, message: "" };
}

export const GameInstanceMessage: MessageFns<GameInstanceMessage> = {
  encode(message: GameInstanceMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameInstanceMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameInstanceMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameInstanceMessage {
    return {
      type: isSet(object.type) ? gameInstanceMessageActionFromJSON(object.type) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: GameInstanceMessage): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = gameInstanceMessageActionToJSON(message.type);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameInstanceMessage>, I>>(base?: I): GameInstanceMessage {
    return GameInstanceMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameInstanceMessage>, I>>(object: I): GameInstanceMessage {
    const message = createBaseGameInstanceMessage();
    message.type = object.type ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseGameTurnStatus(): GameTurnStatus {
  return { playerStatus: undefined, otherPlayers: [] };
}

export const GameTurnStatus: MessageFns<GameTurnStatus> = {
  encode(message: GameTurnStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.playerStatus !== undefined) {
      PlayerStatus.encode(message.playerStatus, writer.uint32(10).fork()).join();
    }
    for (const v of message.otherPlayers) {
      OpponentPlayerStatus.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTurnStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTurnStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.playerStatus = PlayerStatus.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otherPlayers.push(OpponentPlayerStatus.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTurnStatus {
    return {
      playerStatus: isSet(object.playerStatus) ? PlayerStatus.fromJSON(object.playerStatus) : undefined,
      otherPlayers: globalThis.Array.isArray(object?.otherPlayers)
        ? object.otherPlayers.map((e: any) => OpponentPlayerStatus.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GameTurnStatus): unknown {
    const obj: any = {};
    if (message.playerStatus !== undefined) {
      obj.playerStatus = PlayerStatus.toJSON(message.playerStatus);
    }
    if (message.otherPlayers?.length) {
      obj.otherPlayers = message.otherPlayers.map((e) => OpponentPlayerStatus.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameTurnStatus>, I>>(base?: I): GameTurnStatus {
    return GameTurnStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameTurnStatus>, I>>(object: I): GameTurnStatus {
    const message = createBaseGameTurnStatus();
    message.playerStatus = (object.playerStatus !== undefined && object.playerStatus !== null)
      ? PlayerStatus.fromPartial(object.playerStatus)
      : undefined;
    message.otherPlayers = object.otherPlayers?.map((e) => OpponentPlayerStatus.fromPartial(e)) || [];
    return message;
  },
};

function createBasePlayerStatus(): PlayerStatus {
  return { handCards: [], floorCards: [], hiddenCards: 0 };
}

export const PlayerStatus: MessageFns<PlayerStatus> = {
  encode(message: PlayerStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.handCards) {
      Card.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.floorCards) {
      SmallCard.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.hiddenCards !== 0) {
      writer.uint32(24).uint32(message.hiddenCards);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.handCards.push(Card.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.floorCards.push(SmallCard.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hiddenCards = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerStatus {
    return {
      handCards: globalThis.Array.isArray(object?.handCards) ? object.handCards.map((e: any) => Card.fromJSON(e)) : [],
      floorCards: globalThis.Array.isArray(object?.floorCards)
        ? object.floorCards.map((e: any) => SmallCard.fromJSON(e))
        : [],
      hiddenCards: isSet(object.hiddenCards) ? globalThis.Number(object.hiddenCards) : 0,
    };
  },

  toJSON(message: PlayerStatus): unknown {
    const obj: any = {};
    if (message.handCards?.length) {
      obj.handCards = message.handCards.map((e) => Card.toJSON(e));
    }
    if (message.floorCards?.length) {
      obj.floorCards = message.floorCards.map((e) => SmallCard.toJSON(e));
    }
    if (message.hiddenCards !== 0) {
      obj.hiddenCards = Math.round(message.hiddenCards);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerStatus>, I>>(base?: I): PlayerStatus {
    return PlayerStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerStatus>, I>>(object: I): PlayerStatus {
    const message = createBasePlayerStatus();
    message.handCards = object.handCards?.map((e) => Card.fromPartial(e)) || [];
    message.floorCards = object.floorCards?.map((e) => SmallCard.fromPartial(e)) || [];
    message.hiddenCards = object.hiddenCards ?? 0;
    return message;
  },
};

function createBaseOpponentPlayerStatus(): OpponentPlayerStatus {
  return { name: "", handCards: 0, floorCards: [], hiddenCards: 0 };
}

export const OpponentPlayerStatus: MessageFns<OpponentPlayerStatus> = {
  encode(message: OpponentPlayerStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.handCards !== 0) {
      writer.uint32(16).uint32(message.handCards);
    }
    for (const v of message.floorCards) {
      SmallCard.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.hiddenCards !== 0) {
      writer.uint32(32).uint32(message.hiddenCards);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OpponentPlayerStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOpponentPlayerStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.handCards = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.floorCards.push(SmallCard.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hiddenCards = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OpponentPlayerStatus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      handCards: isSet(object.handCards) ? globalThis.Number(object.handCards) : 0,
      floorCards: globalThis.Array.isArray(object?.floorCards)
        ? object.floorCards.map((e: any) => SmallCard.fromJSON(e))
        : [],
      hiddenCards: isSet(object.hiddenCards) ? globalThis.Number(object.hiddenCards) : 0,
    };
  },

  toJSON(message: OpponentPlayerStatus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.handCards !== 0) {
      obj.handCards = Math.round(message.handCards);
    }
    if (message.floorCards?.length) {
      obj.floorCards = message.floorCards.map((e) => SmallCard.toJSON(e));
    }
    if (message.hiddenCards !== 0) {
      obj.hiddenCards = Math.round(message.hiddenCards);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OpponentPlayerStatus>, I>>(base?: I): OpponentPlayerStatus {
    return OpponentPlayerStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OpponentPlayerStatus>, I>>(object: I): OpponentPlayerStatus {
    const message = createBaseOpponentPlayerStatus();
    message.name = object.name ?? "";
    message.handCards = object.handCards ?? 0;
    message.floorCards = object.floorCards?.map((e) => SmallCard.fromPartial(e)) || [];
    message.hiddenCards = object.hiddenCards ?? 0;
    return message;
  },
};

function createBaseGameTurnFeedback(): GameTurnFeedback {
  return { action: 0, message: undefined, hasWon: false, hasDisconnect: false };
}

export const GameTurnFeedback: MessageFns<GameTurnFeedback> = {
  encode(message: GameTurnFeedback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.action !== 0) {
      writer.uint32(8).int32(message.action);
    }
    if (message.message !== undefined) {
      GameInstanceMessage.encode(message.message, writer.uint32(18).fork()).join();
    }
    if (message.hasWon !== false) {
      writer.uint32(24).bool(message.hasWon);
    }
    if (message.hasDisconnect !== false) {
      writer.uint32(32).bool(message.hasDisconnect);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameTurnFeedback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameTurnFeedback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = GameInstanceMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasWon = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hasDisconnect = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameTurnFeedback {
    return {
      action: isSet(object.action) ? gameInstanceActionFromJSON(object.action) : 0,
      message: isSet(object.message) ? GameInstanceMessage.fromJSON(object.message) : undefined,
      hasWon: isSet(object.hasWon) ? globalThis.Boolean(object.hasWon) : false,
      hasDisconnect: isSet(object.hasDisconnect) ? globalThis.Boolean(object.hasDisconnect) : false,
    };
  },

  toJSON(message: GameTurnFeedback): unknown {
    const obj: any = {};
    if (message.action !== 0) {
      obj.action = gameInstanceActionToJSON(message.action);
    }
    if (message.message !== undefined) {
      obj.message = GameInstanceMessage.toJSON(message.message);
    }
    if (message.hasWon !== false) {
      obj.hasWon = message.hasWon;
    }
    if (message.hasDisconnect !== false) {
      obj.hasDisconnect = message.hasDisconnect;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameTurnFeedback>, I>>(base?: I): GameTurnFeedback {
    return GameTurnFeedback.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameTurnFeedback>, I>>(object: I): GameTurnFeedback {
    const message = createBaseGameTurnFeedback();
    message.action = object.action ?? 0;
    message.message = (object.message !== undefined && object.message !== null)
      ? GameInstanceMessage.fromPartial(object.message)
      : undefined;
    message.hasWon = object.hasWon ?? false;
    message.hasDisconnect = object.hasDisconnect ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
